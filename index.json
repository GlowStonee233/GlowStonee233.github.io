[{"content":"VS Code C/C++ 中文乱码修复指南 控制台输出中文乱码的核心原因在于编码不一致。必须确保 源文件、编译器 和 终端 三者统一使用 UTF-8。\n🌟 核心原理：Windows 默认终端编码为 GBK (Code Page 936)，而 VS Code 默认文件编码为 UTF-8。解决乱码的唯一途径是强制将执行环境对齐为 UTF-8。\n1. 统一源文件编码 VS Code 默认创建的文件均为 UTF-8，但需确保并未被意外修改。\n检查编辑器右下角状态栏，确保显示为 UTF-8。 若显示为其他编码（如 GBK），点击该状态栏并选择 Save with encoding -\u0026gt; UTF-8。 📝 如果打开旧文件发现代码本身乱码，请使用 Reopen with encoding 选择正确编码（通常是 GBK）恢复显示，然后再保存为 UTF-8。\n2. 配置 Code Runner (最佳实践) 为了避免每次手动切换终端编码，我们通过修改 Code Runner 的执行指令实现自动化。\n推荐使用 PowerShell 的对象操作 [Console]::OutputEncoding 替代传统的 chcp 命令，以避免副作用。\n请打开 VS Code 设置文件：\n📄 settings.json { \u0026#34;code-runner.executorMap\u0026#34;: { \u0026#34;c\u0026#34;: \u0026#34;cd $dir; gcc -fexec-charset=UTF-8 \u0026#39;$fileName\u0026#39; -o \u0026#39;$fileNameWithoutExt\u0026#39;; if ($?) { [Console]::OutputEncoding = [System.Text.Encoding]::UTF8; .\\\\\u0026#39;$fileNameWithoutExt\u0026#39; }\u0026#34; } } 🤔 点击展开：命令逐行深度解析 这段脚本利用了 PowerShell 的特性来确保执行流程的稳健性：\ngcc -fexec-charset=UTF-8： 告诉 GCC 编译器，程序执行时的字符串（exec-charset）应按 UTF-8 编码处理，防止编译器按 Windows 默认的 GBK 编译字符串。 if ($?) { ... }： $? 是 PowerShell 的布尔变量，代表上一条命令（GCC 编译）是否成功。 只有编译成功（Return 0），才会执行后续的运行指令。 [Console]::OutputEncoding = ...： 关键点：直接修改当前会话的 .NET 控制台输出对象编码。比 chcp 更底层且稳定。 .\\\\'$fileNameWithoutExt'： 运行编译后的可执行文件。 3. 避坑指南：为什么不用 chcp 65001？ 网络上常见的方案是使用 chcp 65001 命令，虽然能解决乱码，但它对 PowerShell 的兼容性极差。\n⚠️ 副作用警告：在 PowerShell 中使用 chcp 65001 不稳定，容易导致界面被清空或命令提示符 (Prompt) 丢失，严重影响后续交互。\n如果你正在使用以下旧配置，建议替换为第 2 节中的方案：\n📄 settings.json (Deprecated) // ❌ 不推荐的写法 { \u0026#34;c\u0026#34;: \u0026#34;...; if ($?) { chcp 65001 | Out-Null; .\\\\\u0026#39;$fileNameWithoutExt\u0026#39; }\u0026#34;, } 4. 终端环境建议 Windows 的 GBK 历史包袱是乱码问题的根源，选择合适的终端环境可以大幅提升体验。\n坚守 Windows：请安装 Windows Terminal。 💡 如果不想折腾虚拟机，微软推出的 Windows Terminal 是最佳选择。它对 Unicode 字符渲染支持极佳，界面现代化，且不会出现旧版 cmd/powershell 窗口的各类渲染 Bug。\n彻底根治：转向 Linux / WSL。 💡 Linux 环境原生支持 UTF-8，彻底不存在此类编码问题。如果你愿意深入学习，建议在 Windows 上启用 **WSL 进行开发。\n","permalink":"https://GlowStonee233.github.io/posts/2026/vs-code-c/c-%E6%8E%A7%E5%88%B6%E5%8F%B0%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E5%AE%8C%E5%85%A8%E4%BF%AE%E5%A4%8D%E6%8C%87%E5%8D%97/","summary":"本文深入解析编码不一致导致的乱码根源，提供基于 PowerShell 和 GCC 参数的 Code Runner 配置方案，彻底解决 Windows 环境下的中文显示问题。","title":"VS Code C/C++ 控制台中文乱码完全修复指南"},{"content":"本文用于演示数学公式渲染与 GitHub 风格的五种 Alert 警告框，同时包含折叠块和代码文件头效果。\n1. 数学公式演示 行内公式 这是一个行内公式测试：质能方程 $E = mc^2$。在描述序列时，可以写作 $a_{n_1} \\leq a_{n_2} \\leq \\cdots$。\n块级公式 以下是等差数列求和的推导结论： $$ \\sum_{i=1}^{n} i = \\frac{n(n+1)}{2} $$以及基础的分数运算展示： $$ \\frac{1}{2} + \\frac{1}{3} = \\frac{5}{6} $$ 2. GitHub 警告框测试 (Alerts) 这里演示 GitHub 官方支持的五种警告框样式，用于区分信息的重要程度。\n📝 这是一个 NOTE 警告框。用于强调用户在快速浏览时也不应忽略的重要信息。\n💡 这是一个 TIP 警告框。用于提供辅助信息，帮助用户更高效地完成任务。\n🌟 这是一个 IMPORTANT 警告框。对于用户成功完成目标至关重要的关键信息。\n⚠️ 这是一个 WARNING 警告框。需要用户立即关注的重要内容，以避免潜在问题。\n🛑 这是一个 CAUTION 警告框。针对某些操作可能带来的负面后果进行提醒。\n3. 代码文件头与逻辑演示 演示如何通过 codefile 展示带有路径的代码块。\n📄 math/summation.py def check_sum(n): # 使用公式 n(n+1)/2 验证 formula_result = n * (n + 1) // 2 loop_result = sum(range(1, n + 1)) return formula_result == loop_result print(f\u0026#34;验证结果: {check_sum(100)}\u0026#34;) 4. 交互式折叠块 (Details) 用于隐藏复杂的证明过程或次要信息。\n核心结论： 黎曼 zeta 函数在特定点的值具有美感。\n🤔 点击展开：查看相关公式推导 这里是隐藏的数学细节： $$ \\zeta(2) = \\sum_{n=1}^{\\infty} \\frac{1}{n^2} = \\frac{\\pi^2}{6} $$ 以及更多关于无限级数的讨论。只有点击标题才会看到这些深奥的内容。\n5. 综合实战场景 下面模拟一个配置数学渲染引擎的真实场景：\n🌟 在修改生产环境的配置文件前，请务必执行备份操作。\n📄 config/mathjax.json { \u0026#34;tex\u0026#34;: { \u0026#34;inlineMath\u0026#34;: [[\u0026#34;$\u0026#34;, \u0026#34;$\u0026#34;]], \u0026#34;displayMath\u0026#34;: [[\u0026#34;$$\u0026#34;, \u0026#34;$$\u0026#34;]] }, \u0026#34;svg\u0026#34;: { \u0026#34;fontCache\u0026#34;: \u0026#34;global\u0026#34; } } 🛑 错误的 JSON 语法会导致整个页面的数学公式无法正常渲染，请使用验证工具检查。\n🔍 遇到渲染报错怎么办？ 检查浏览器控制台 (F12) 是否有 JS 加载失败的报错。 确认公式语法是否符合 LaTeX 标准。 清除静态网站生成器的缓存并重新构建。 ","permalink":"https://GlowStonee233.github.io/posts/2026/%E7%BB%BC%E5%90%88%E5%8A%9F%E8%83%BD%E6%B5%8B%E8%AF%95%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E4%B8%8E-github-%E6%A0%B7%E5%BC%8F/","summary":"\u003cp\u003e本文用于演示数学公式渲染与 GitHub 风格的五种 Alert 警告框，同时包含折叠块和代码文件头效果。\u003c/p\u003e\n\u003ch2 id=\"1-数学公式演示\"\u003e1. 数学公式演示\u003c/h2\u003e\n\u003ch3 id=\"行内公式\"\u003e行内公式\u003c/h3\u003e\n\u003cp\u003e这是一个行内公式测试：质能方程 $E = mc^2$。在描述序列时，可以写作 $a_{n_1} \\leq a_{n_2} \\leq \\cdots$。\u003c/p\u003e\n\u003ch3 id=\"块级公式\"\u003e块级公式\u003c/h3\u003e\n\u003cp\u003e以下是等差数列求和的推导结论：\n\u003c/p\u003e\n$$\n\\sum_{i=1}^{n} i = \\frac{n(n+1)}{2}\n$$\u003cp\u003e以及基础的分数运算展示：\n\u003c/p\u003e\n$$\n\\frac{1}{2} + \\frac{1}{3} = \\frac{5}{6}\n$$\u003chr\u003e\n\u003ch2 id=\"2-github-警告框测试-alerts\"\u003e2. GitHub 警告框测试 (Alerts)\u003c/h2\u003e\n\u003cp\u003e这里演示 GitHub 官方支持的五种警告框样式，用于区分信息的重要程度。\u003c/p\u003e\n\n  \n  \u003cdiv class=\"callout callout-note\"\u003e\n      \u003cdiv class=\"callout-icon\"\u003e📝\u003c/div\u003e\n      \u003cdiv class=\"callout-content\"\u003e\u003cp\u003e这是一个 \u003cstrong\u003eNOTE\u003c/strong\u003e 警告框。用于强调用户在快速浏览时也不应忽略的重要信息。\u003c/p\u003e\n      \u003c/div\u003e\n  \u003c/div\u003e\n  \n  \u003cdiv class=\"callout callout-tip\"\u003e\n      \u003cdiv class=\"callout-icon\"\u003e💡\u003c/div\u003e\n      \u003cdiv class=\"callout-content\"\u003e\u003cp\u003e这是一个 \u003cstrong\u003eTIP\u003c/strong\u003e 警告框。用于提供辅助信息，帮助用户更高效地完成任务。\u003c/p\u003e\n      \u003c/div\u003e\n  \u003c/div\u003e\n  \n\n  \n  \u003cdiv class=\"callout callout-important\"\u003e\n      \u003cdiv class=\"callout-icon\"\u003e🌟\u003c/div\u003e\n      \u003cdiv class=\"callout-content\"\u003e\u003cp\u003e这是一个 \u003cstrong\u003eIMPORTANT\u003c/strong\u003e 警告框。对于用户成功完成目标至关重要的关键信息。\u003c/p\u003e\n      \u003c/div\u003e\n  \u003c/div\u003e\n  \n  \u003cdiv class=\"callout callout-warning\"\u003e\n      \u003cdiv class=\"callout-icon\"\u003e⚠️\u003c/div\u003e\n      \u003cdiv class=\"callout-content\"\u003e\u003cp\u003e这是一个 \u003cstrong\u003eWARNING\u003c/strong\u003e 警告框。需要用户立即关注的重要内容，以避免潜在问题。\u003c/p\u003e\n      \u003c/div\u003e\n  \u003c/div\u003e\n  \u003cdiv class=\"callout callout-caution\"\u003e\n      \u003cdiv class=\"callout-icon\"\u003e🛑\u003c/div\u003e\n      \u003cdiv class=\"callout-content\"\u003e\u003cp\u003e这是一个 \u003cstrong\u003eCAUTION\u003c/strong\u003e 警告框。针对某些操作可能带来的负面后果进行提醒。\u003c/p\u003e\n      \u003c/div\u003e\n  \u003c/div\u003e\u003chr\u003e\n\u003ch2 id=\"3-代码文件头与逻辑演示\"\u003e3. 代码文件头与逻辑演示\u003c/h2\u003e\n\u003cp\u003e演示如何通过 \u003ccode\u003ecodefile\u003c/code\u003e 展示带有路径的代码块。\u003c/p\u003e\n\n\n\n\u003cdiv class=\"code-file-header\"\u003e\n    \n    \n    \u003cspan class=\"file-icon\"\u003e📄\u003c/span\u003e\n    \n    \n    \u003cspan class=\"file-name\"\u003emath/summation.py\u003c/span\u003e\n\n\u003c/div\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003edef\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003echeck_sum\u003c/span\u003e(n):\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#75715e\"\u003e# 使用公式 n(n+1)/2 验证\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    formula_result \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e n \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003e (n \u003cspan style=\"color:#f92672\"\u003e+\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e) \u003cspan style=\"color:#f92672\"\u003e//\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e2\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    loop_result \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e sum(range(\u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e, n \u003cspan style=\"color:#f92672\"\u003e+\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e))\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e formula_result \u003cspan style=\"color:#f92672\"\u003e==\u003c/span\u003e loop_result\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eprint(\u003cspan style=\"color:#e6db74\"\u003ef\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;验证结果: \u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e{\u003c/span\u003echeck_sum(\u003cspan style=\"color:#ae81ff\"\u003e100\u003c/span\u003e)\u003cspan style=\"color:#e6db74\"\u003e}\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003chr\u003e\n\u003ch2 id=\"4-交互式折叠块-details\"\u003e4. 交互式折叠块 (Details)\u003c/h2\u003e\n\u003cp\u003e用于隐藏复杂的证明过程或次要信息。\u003c/p\u003e","title":"综合功能测试：数学公式与 GitHub 样式"},{"content":"单调子列定理 任意无限实数数列，都必然存在一个单调子列。\n📝 定义：单调子列 (Monotone Subsequence) 子列中的项满足 $a_{n_1} \\leq a_{n_2} \\leq \\cdots$ (单调不减) 或 $a_{n_1} \\geq a_{n_2} \\geq \\cdots$ (单调不增)。注意，它包含了相等的情况 (非严格单调)。\n本证明的核心是引入“峰值” (peak) 这一概念，并基于峰值的数量进行分类讨论。\n📝 定义：峰值 (Peak) 数列中的一项 $a_k$ 是一个峰值，如果它不小于其后出现的任何项。即，对所有 $n \u003e k$，都有 $a_k \\geq a_n$。\n💡 直觉：什么是峰值？ 想象一座山脉，一个峰值就是一个山顶，其后只有下坡或平路，再无更高的山峰。\n数列 $\\{5, 4, 3, 2, 1\\}$ 中，每一项都是峰值。 数列 $\\{1, 2, 3, 4, 5\\}$ 中，没有任何一项是峰值。 数列 $\\{1, 5, 2, 4, 3\\}$ 中，$5$ 和 $4$ 是峰值。 证明的逻辑分为以下两种互斥且完备的情况。\n情况一：数列存在无限个峰值。\n这些峰值本身就构成一个单调不增 (non-increasing) 的子列。\n🔍 说明 设这些峰值的下标序列为 $k_1 \u003c k_2 \u003c k_3 \u003c \\cdots$。根据峰值的定义，对于任意一个峰值 $a_{k_i}$，它必然不小于其后的所有项。因为 $k_{i+1} \u003e k_i$，所以 $a_{k_{i+1}}$ 是 $a_{k_i}$ “其后的项”之一。因此，必然有 $a_{k_i} \\geq a_{k_{i+1}}$。这个关系对所有 $i$ 都成立，故子列 $\\{ a_{k_i} \\}$ 是单调不增的。\n情况二：数列仅有有限个（或零个）峰值。\n在这种情况下，我们可以构造出一个严格单调递增 (strictly increasing) 的子列。\n🔍 说明\n设最后一个峰值的下标为 $K$ (如果不存在峰值，则令 $K=0$) 。 从 $n_1 = K+1$ 开始，我们知道 $a_{n_1}$ 不是峰值。 根据“非峰值”的定义，必然存在一个下标 $n_2 \u003e n_1$，使得 $a_{n_2} \u003e a_{n_1}$。 同理，$a_{n_2}$ 也不是峰值，所以必然存在 $n_3 \u003e n_2$，使得 $a_{n_3} \u003e a_{n_2}$。 重复此过程，我们就能构建一个下标序列 $n_1 \u003c n_2 \u003c n_3 \u003c \\cdots$，其对应的子列 $\\{ a_{n_i} \\}$ 满足 $a_{n_1} \u003c a_{n_2} \u003c a_{n_3} \u003c \\cdots$，是一个严格单调递增子列。 结论\n无论哪种情况，我们总能成功找到一个单调子列。定理得证。\n💡 背景：与 Bolzano-Weierstrass 定理的关系 这个单调子列定理是证明“有界数列必有收敛子列”（即 Bolzano-Weierstrass 定理）的关键一步。证明思路是：首先利用本定理从任意有界数列中找到一个单调子列，然后根据“有界单调数列必收敛”这一准则，得出该子列必然收敛。\n","permalink":"https://GlowStonee233.github.io/posts/2026/%E4%BB%BB%E6%84%8F%E6%97%A0%E9%99%90%E5%AE%9E%E6%95%B0%E6%95%B0%E5%88%97%E5%BF%85%E6%9C%89%E5%8D%95%E8%B0%83%E5%AD%90%E5%88%97%E7%9A%84%E4%B8%80%E4%B8%AA%E4%BC%98%E9%9B%85%E8%AF%81%E6%98%8E/","summary":"本文利用“峰值”概念，对任意无限实数数列中必然存在单调子列这一经典定理给出了一个清晰直观的证明。","title":"任意无限实数数列必有单调子列的一个优雅证明"},{"content":"我日常在 WSL中开发，享受着它带来的无缝体验。但最近，一个问题几乎让我放弃它：Git 慢到无法使用。本文记录了我从抓狂到解决问题的全过程，希望能帮你绕开我踩过的所有坑。\n初步尝试与屡屡碰壁 一切始于我们将一个 C 语言项目从原生 Windows 迁移至 WSL 环境。\n问题：网络隔离 项目迁移后，我无法从 WSL 中正常 git clone 或 git push 到远程仓库。\n⚠️ 坑点：WSL 的独立网络栈： WSL 拥有自己的一套虚拟网络，它与宿主机 Windows 并不直接共享 localhost (127.0.0.1)。因此，你在 Windows 上运行的代理服务，对于 WSL 内部的程序来说，并不能通过 localhost 访问到。\n迷宫般的代理配置 我当时第一反应是在 WSL 中为 Git 配置代理。\n尝试一：直接指向 localhost，失败。 我尝试在 WSL 的 .gitconfig 中设置 http.proxy 指向 Windows 代理的端口（如 http://127.0.0.1:7890），但连接被拒绝。\n尝试二：移植代理客户端到 WSL，失败。 我试图将代理工具（如 V2Ray）直接在 WSL 内部运行。但这带来了新的问题：复杂的配置、找不到合适的 Linux 版本，以及端口被占用的冲突。\n在这条路，我彻底走进了死胡同。\n曲线救国和新问题 在 WSL 原生 Git 走不通后，我决定换个思路。\n调用 Windows Git 我利用了 WSL 的一个强大特性：可以调用Windows上的可执行文件。\n我直接在 WSL 命令行中调用 Windows 环境中的 git.exe 来执行所有 Git 操作。\n# 在 WSL 中调用 Windows 的 Git /mnt/c/Program\\ Files/Git/bin/git.exe clone [repository_url] 这立刻解决了网络问题。Windows 的 Git 自然地使用了 Windows 的网络配置，Git的clone和push都恢复了正常。\n💡 为什么可以这样做？ WSL 允许你在 Linux 环境中直接调用 Windows 的可执行文件 (.exe)，反之亦然。这是一个非常强大的“胶水”特性，能让你组合利用两个系统的优势。\n新瓶颈和问题 在 WSL 中直接调用 Windows Git (git.exe) 会带来两个新瓶颈。\n💡 背景: 此前的方案（在 WSL 中调用 Windows Git）初步解决了“有没有”的问题，但很快就暴露了可用性和性能上的新瓶颈。\n一是命令冗长复杂，降低了操作效率。二是跨文件系统的 I/O 损耗，导致性能下降。\n⚠️ 坑点：命令的复杂与分裂\n在 WSL 中，调用 git.exe 需要写很长的路径（如 /mnt/c/.../git.exe），即便使用别名 (alias) 也难以优雅地管理。若为了简化而只用它处理部分操作（如网络推送），则会破坏命令的统一性，在开发者脑中形成两个分裂的 Git，增加心智负担。\n这本质上是 WSL 的架构限制所致。\n🔍 细节：跨文件系统的性能开销 WSL 的架构决定了其跨文件系统的性能瓶颈。当 WSL 内的进程（如 bash）操作 Windows 文件（挂载于 /mnt/*）时，或 Windows 进程操作 WSL 文件（位于 \\\\wsl$\\*）时，都会因额外的转换和通信层而产生显著的性能开销。调用 git.exe 正是后一种情况。\n结论：必须回归使用 WSL 原生的 Git。\n回归初心，根治 WSL 原生 Git 既然“曲线救国”的路也堵死了，我决定正面解决问题。\n问题到底出在哪？ 我曾怀疑是 WSL 的 NAT (网络地址转换) 导致了性能问题，搜索后探究到发现并非如此。\n🔍 细节：NAT 并非瓶颈 WSL 的虚拟交换机 NAT 性能极高（可达 10Gbps 级别），而我通过代理访问公网的瓶颈在于代理节点带宽和国际出口（约 30Mbps）。真正的瓶颈与 NAT 无关。\n那为什么 Clone 大仓库时总是会中断？后来我使用下面的方法解决的问题，发现问题可能不在网络层，而是在应用协议层，有以下可能。\n协议不兼容：HTTP/2 协议在通过复杂的代理链路时，其多路复用特性可能因丢包或乱序导致连接重置。 超时太敏感：Git 默认的超时机制对网络抖动（Jitter）过于敏感，在跨国网络中容易误判连接失败而主动中断。 缓冲区太小：在高延迟网络下，过小的缓冲区导致了过多的网络 I/O 交互，增加了出错的概率。 最终配置 我制定了最终配置可能是针对解决了以上三个可能的协议层问题，\n1.动态获取宿主机 IP\n要让 WSL 里的 Git 找到 Windows 的代理，就必须知道 Windows 的真实 IP。\n我编写了一个简单的脚本，每次启动 shell 时自动获取宿主机 IP，并设置好代理,写入脚本后使用source ~/.bashrc或者source ~/.zshrc使配置生效。\n📝 获取宿主机 IP 的脚本 在你的 .bashrc 或 .zshrc 中加入以下脚本。它会解析 resolv.conf 文件来找到 Windows 主机的 IP，并设置 ALL_PROXY 环境变量。\n# 获取 Windows Host IP 并设置代理 export HOST_IP=$(cat /etc/resolv.conf | grep nameserver | awk \u0026#39;{print $2}\u0026#39;) export PROXY_PORT=10800 # 你的 Windows 代理端口 export ALL_PROXY=\u0026#34;socks5://${HOST_IP}:${PROXY_PORT}\u0026#34; # 你也可以选择直接修改 git config，但环境变量更灵活 # git config --global http.proxy \u0026#34;http://${HOST_IP}:${PROXY_PORT}\u0026#34; # git config --global https.proxy \u0026#34;http://${HOST_IP}:${PROXY_PORT}\u0026#34; 💡 Windows 11 的镜像网络：Win11 高版本引入了 Mirrored Networking，它可以让 WSL 与 Windows 共享网络，直接使用 localhost 即可。如果你使用 Win11 ，强烈建议开启此功能，可以省去以上脚本。\n2.优化 Git 传输参数\n这是最关键的一步。我在 Git 全局配置中加入了三行配置。\ngit config --global http.version HTTP/1.1 git config --global http.postBuffer 157286400 git config --global core.lowSpeedLimit 0 git config --global core.lowSpeedTime 999999 🔍 原理：这三行配置到底做了什么？\nhttp.version HTTP/1.1：强制 Git 降级使用更稳定、更兼容的 HTTP/1.1 协议，避开 HTTP/2 在复杂代理环境下的“水土不服”。 http.postBuffer 157286400：将 POST 请求的缓冲区增大到 150MB。对于 git push 等操作，这意味着 Git 会在内存里准备好一个大文件块再进行单次、大块的传输，显著减少高延迟网络下的交互次数。 core.lowSpeedLimit / core.lowSpeedTime：基本禁用了 Git 自身的超时检测机制，允许连接在网络临时抖动或速度极慢时“苟活”下来，把连接管理的任务完全交给底层的 TCP 协议。 3.使用 Linux 原生文件系统\n这是确保 I/O 性能的铁律。\n永远在 WSL 的主目录 (~) 或其他 Linux 文件系统路径下执行 Git 操作。\n第四阶段：战果与反思 配置完成后，我进行了测试。\n效果检验：Clone Linux 内核仓库 我选择 Clone Linux 内核这个巨型仓库 Linux Kernel。\n结果令人振奋：\n仓库大小：5.60 GiB 耗时：约 26 分钟 平均速度：约 3.43 MiB/s 过程：全程稳定，无任何断连或报错。 这证明了问题已经得到圆满解决。\n总结与最终配置 回顾整个过程，解决 WSL 中 Git 性能问题的关键在于找到核心问题，将问题定位到协议问题。\n📝 最终推荐配置 以下是我沉淀下来的最终配置，融合了所有优化和一些额外建议。\n1. Shell 启动脚本 (~/.bashrc 或 ~/.zshrc)\n# For Win10 or Win11 without Mirrored Networking export HOST_IP=$(cat /etc/resolv.conf | grep nameserver | awk \u0026#39;{print $2}\u0026#39;) export PROXY_PORT=7890 # 修改为你的代理端口 export ALL_PROXY=\u0026#34;socks5://${HOST_IP}:${PROXY_PORT}\u0026#34; 2. Git 全局配置 (~/.gitconfig)\n[http] postBuffer = 157286400 version = HTTP/1.1 [core] lowSpeedLimit = 0 lowSpeedTime = 999999 # [http] # maxRequests = 5 # 警告：此配置可提高并发，但是我没有试过，可能存在被服务器Ban掉的风险，请谨慎使用 ⚠️ 注意：我移除了之前测试用的 core.fscache，因为它在 Linux 下无效，是 Windows 专用的 Git 缓存配置。\n如果仅仅是为了解决 Git 问题无需升级系统，但从长远看，如果条件允许，我依然推荐升级到 Windows 11，并开启镜像网络。它能从根本上解决 WSL 与 Windows 的网络差异，一劳永逸地解决 IP 变动、VPN 穿透等诸多网络难题，还能原生支持 Linux GUI 应用，整体开发体验会再上一个台阶。\n以上\n","permalink":"https://GlowStonee233.github.io/posts/2026/windows-10-%E4%B8%8B-wsl-git%E7%9A%84%E4%B8%80%E4%B8%AAclone%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3/","summary":"深入解析 WSL 网络隔离导致的 Git 性能问题，提供代理配置、Git 参数调优及文件系统最佳实践，彻底解决 Clone 慢与超时。","title":"Windows 10下 WSL Git的一个clone性能问题的解决"},{"content":"1. 前言：为什么要折腾 WSL？ 临近期末，复习C语言时实在是受不了Visual Studio复杂的操作（还没法直接写C），但是用VScode又被Windows的终端编码（GBK）搞的痛不欲生\n听说Linux编程配环境很容易，但是又不想放弃Windows的娱乐优势，所以学习了WSL来平衡二者。\n这篇文章记录了从简单的命令行到GDB调试的全过程，用于备忘。\n2. 环境准备与基础命令 2.1 环境架构 系统: Windows 11 25H2 + WSL2 (我用的是 Ubuntu) 编译器: GCC 调试器: GDB 编辑器: VS Code 2.2 WSL 基础命令 在 PowerShell 中，可以用几个简单命令管理 WSL：\n# 启动并进入默认的 Linux 发行版 wsl # 查看已安装的发行版及其版本（最好用WSL2） wsl -l -v 注意：从隔离的角度考虑，最好在在 Linux 的 /home/用户名 目录下进行代码开发**，不要跨盘操作（如 /mnt/c）。\n几个高频使用的终端命令：\npwd # 确认当前路径 ls -l # 列出文件详细信息 cd ~ # 快速回到 /home 目录，这里~=/home/用户名 mkdir code # 创建项目文件夹，使用-p参数来递归创建文件夹 2.3 安装核心开发工具 刚装好的 Ubuntu 可能不带开发工具，需要手动安装 build-essential 包，它包含了 gcc, g++, make 等一系列开发必备工具。\nsudo apt update sudo apt install build-essential 3. GCC 和 GDB 常见命令与内部逻辑 在配置 IDE 之前，必须先熟练掌握底层的命令行逻辑。为了演示 GDB 的强大，我们先来写一段看似没问题但结果错误的代码。\n3.1 这是一个有BUG的程序 创建一个名为 test.c 的文件，目的是计算 1 到 n 的和：\n#include \u0026lt;stdio.h\u0026gt; int main(){ int n; int sum; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (int i = 1; i \u0026lt;= n; i++){ sum += i; } printf(\u0026#34;%d\\n\u0026#34;, sum); return 0; } 3.2 编译器 (GCC) 的标准命令 不要只会用 gcc test.c，养成添加标准参数的习惯，这能帮你发现无数潜在的 Bug。\n# 推荐的编译指令，参数详解： # -g : 生成调试信息（GDB 调试必须加，否则看不到源码和变量名） # -Wall : 开启所有警告（这对排查隐患至关重要） # -std=c11 : 指定 C11 标准，可以更换 # -o demo : 指定输出的可执行文件名为 demo gcc test.c -g -Wall -std=c11 -o demo 3.3 一个用GDB排除BUG的案例 以下，我将会模拟一场真实的BUG排查。\n第一步：编译并启动调试\ngcc test.c -g -o demo gdb ./demo 第二步：打断点 我们希望程序停在 main 函数刚开始的地方，好让我们一步步观察。\n(gdb) b main # b命令，打断点，支持按行数打断点 Breakpoint 1 at 0x1195: file test.c, line 3. 第三步：运行程序\n(gdb) r # r命令，运行程序 Starting program: /home/yourname/code/demo Breakpoint 1, main () at test.c:3 3 int main(){ 此时，程序停在了第 3 行，还没执行。\n第四步：单步执行与查看变量 这是最关键的一步。我们往下走几步，看看 sum 的值。\n注意，GDB只会检查执行语句，变量声明会直接跳过（除非变量在声明时就进行了赋值操作，如 int n = 0;），所以就从第3行跳到了第6行。\n(gdb) n 6 scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); (gdb) n 5 #输入n的值 8 for (int i = 1; i \u0026lt;= n; i++){ 此时，sum 已经被声明，但还没进入循环。让我们看看现在 sum 里面是什么：\n(gdb) p sum # p命令，打印变量值 $1 = -8944 # 发现是一个奇怪的值，说明是内存中的垃圾值 得出结论：因为没有初始化 sum = 0，它直接拿内存里的垃圾值去累加了，所以结果会不对。\n第五步：退出 (Quit) 找到问题后，退出 GDB 去修改代码。\n(gdb) q # q命令，退出调试 4.配置 VS Code 实现一键图形化调试 理解了上面的命令行全过程后，我们就可以通过配置让 VS Code 帮我们“代劳”，实现F5 一键图形化调试。\n4.1 连接 WSL VScode必须安装 WSL 插件。 在 WSL 终端进入你的项目目录：cd ~/code。 输入 code . 启动 VS Code。 看到 VS Code 左下角显示 WSL: Ubuntu 即表示连接成功。 4.2 配置 tasks.json (代替手工 GCC) 我们的目标是：按下 Ctrl+Shift+B 自动执行上面那串 gcc 编译命令。\n在项目根目录创建 .vscode/tasks.json 文件，填入以下内容：\n{ \u0026#34;version\u0026#34;: \u0026#34;2.0.0\u0026#34;, \u0026#34;tasks\u0026#34;: [ { \u0026#34;label\u0026#34;: \u0026#34;GCC Build Active File\u0026#34;, // 任务标签，记注它，后面要用 \u0026#34;type\u0026#34;: \u0026#34;shell\u0026#34;, \u0026#34;command\u0026#34;: \u0026#34;/usr/bin/gcc\u0026#34;, \u0026#34;args\u0026#34;: [ \u0026#34;-g\u0026#34;, // 必须有，否则无法调试 \u0026#34;${file}\u0026#34;, // 当前打开的文件名 \u0026#34;-o\u0026#34;, \u0026#34;${fileDirname}/${fileBasenameNoExtension}.out\u0026#34;, // 输出为同名.out文件 \u0026#34;-std=c11\u0026#34;, \u0026#34;-Wall\u0026#34; ], \u0026#34;group\u0026#34;: { \u0026#34;kind\u0026#34;: \u0026#34;build\u0026#34;, \u0026#34;isDefault\u0026#34;: true }, \u0026#34;problemMatcher\u0026#34;: [\u0026#34;$gcc\u0026#34;] } ] } 4.3 配置 launch.json (代替手工 GDB) 我们的目标是：按下 F5，自动调用上面的编译任务，然后启动 GDB 图形化调试。\n在 .vscode/launch.json 文件中填入以下内容：\n{ \u0026#34;version\u0026#34;: \u0026#34;0.2.0\u0026#34;, \u0026#34;configurations\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;GDB Debug Active File\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;cppdbg\u0026#34;, \u0026#34;request\u0026#34;: \u0026#34;launch\u0026#34;, \u0026#34;program\u0026#34;: \u0026#34;${fileDirname}/${fileBasenameNoExtension}.out\u0026#34;, \u0026#34;args\u0026#34;: [], \u0026#34;stopAtEntry\u0026#34;: false, \u0026#34;cwd\u0026#34;: \u0026#34;${fileDirname}\u0026#34;, \u0026#34;environment\u0026#34;: [], \u0026#34;externalConsole\u0026#34;: false, \u0026#34;MIMode\u0026#34;: \u0026#34;gdb\u0026#34;, \u0026#34;setupCommands\u0026#34;: [ { \u0026#34;description\u0026#34;: \u0026#34;为 GDB 启用整齐打印\u0026#34;, \u0026#34;text\u0026#34;: \u0026#34;-enable-pretty-printing\u0026#34;, \u0026#34;ignoreFailures\u0026#34;: true } ], // 关键！调试前先自动跑一遍上面的编译任务 \u0026#34;preLaunchTask\u0026#34;: \u0026#34;GCC Build Active File\u0026#34; } ] } 配置好后，你就可以用鼠标在行号左边打断点，按 F5 启动调试，在左侧栏实时查看变量值了！\n5. 使用 CMake 管理多文件项目 对于单文件，gcc 足够了。但如果是多文件项目，手写 gcc main.c utils.c helper.c ... 会很痛苦。这时就该用 CMake 。\n项目结构示例：\nproject/ ├── CMakeLists.txt ├── main.c └── utils.c CMakeLists.txt 模板：\n# CMake 最低版本要求 cmake_minimum_required(VERSION 3.16) # 项目名称和语言 project(my_c_project C) # 设置 C 语言标准 set(CMAKE_C_STANDARD 11) # 添加可执行文件，源文件列表写在后面 add_executable(app main.c utils.c) 构建流程：\n# 创建一个 build 文件夹存放编译产物 mkdir build \u0026amp;\u0026amp; cd build # 生成 Makefile cmake .. # 执行编译 make # 或者用 cmake 命令 # cmake --build . 6. 避坑指南与总结 编译参数的选择 (-g 和 -Wall)： 再次强调 -g 和 -Wall 的重要性。前者是 GDB 调试的入场券，后者能帮你提前发现无数低级错误（比如变量未初始化），省下大量调试时间。\nVS Code 配置核对： 按下 F5 提示 preLaunchTask 错误？检查 launch.json 里的 preLaunchTask 名字是否和 tasks.json 里的 label 完全一致。\n适当使用 \u0026ldquo;Code Runner\u0026rdquo; 插件： VS Code 的 Code Runner 插件虽然方便，但它隐藏了具体的编译命令，一键运行很爽，但对学习毫无帮助。建议在学习阶段手动敲终端命令或使用我们配置的 F5 调试流程，理解编译、链接的全过程。\n","permalink":"https://GlowStonee233.github.io/posts/2026/%E6%88%91%E7%9A%84-wsl-c%E8%AF%AD%E8%A8%80%E7%8E%AF%E5%A2%83%E5%A4%87%E5%BF%98%E5%BD%95/","summary":"为备战C语言考试，也为日常开发，我基于 WSL 搭建了一套 C 语言环境。这篇备忘录记录了从 GDB 命令行手动捉虫，到 VS Code 一键调试的全流程配置，防止以后自己忘记。","title":"我的 WSL C语言环境备忘录"},{"content":"最近在向 GitHub 推送代码时，网络又开始抽风。无论是 git push 还是 git pull，都大概率会卡在某个地方，然后给我一个冰冷的 Connection refused 或者 Connection reset。就算切换到 SSH 协议，有时也难逃一劫。\n每次遇到这个问题都要重新搜索一遍解决方案，效率太低。为了防止以后自己忘记，也为了形成一个可以快速查阅的备忘录，我决定把几种主流的解决方案整理成一篇文章，彻底搞定这个问题。\n1. 背景与常见错误 问题的核心在于本地网络环境与 GitHub 服务器之间的网络连接不稳定或存在策略性阻断。这通常会导致以下几种典型的错误信息：\n通过 SSH 协议访问时：\nssh: connect to host github.com port 22: Connection refused fatal: Could not read from remote repository. Please make sure you have the correct access rights and the repository exists. 或者在测试 SSH 连通性时出现：\n$ ssh -T git@github.com Connection reset by 20.205.243.160 port 443 我们的目标就是通过配置代理，让 Git 的网络请求绕过不稳定的链路，从而实现稳定访问。\n2. 准备工作：确认代理端口 在开始配置之前，必须先确认本地代理软件监听的协议和端口。如果这里搞错了，后续的所有配置都将无效。\nClash: 通常 HTTP 代理端口为 7890，SOCKS5 代理端口为 7891。 V2RayN/V2RayU: 通常 HTTP 代理端口为 10808，SOCKS5 代理端口为 10809。 Shadowsocks: 通常 SOCKS5 代理端口为 1080。 提示：具体端口请以代理软件设置界面显示的为准。\n3. 方案一：通过 SSH 配置代理 这个方案是我最推荐的，因为它只对 github.com 的 SSH 连接生效，不会影响其他任何工具或网站的访问，而且配置一次后就无需再关心。它适用于远程仓库地址格式为 git@github.com:user/repo.git 的情况。\n步骤 1: 编辑 SSH 配置文件 打开终端，使用你熟悉的编辑器（如 vim 或 nano 或 vscode）编辑 SSH 用户配置文件。如果文件不存在，这个命令会自动创建它。\n# 可以用nano nano ~/.ssh/config 步骤 2: 添加代理配置 在打开的文件中，添加以下内容。请注意区分操作系统，因为它们使用的代理命令工具不同。\n对于 macOS / Linux 用户：\nHost github.com Hostname ssh.github.com Port 443 User git # 使用 nc (netcat) 作为代理命令，-x 参数表示 SOCKS5 代理 # 如果你的代理是 HTTP 类型，可以尝试将 -x 改为 -X connect ProxyCommand nc -v -x 127.0.0.1:7891 %h %p 对于 Windows (Git Bash) 用户：\nHost github.com Hostname ssh.github.com Port 443 User git # Git for Windows 自带了 connect.exe 工具 # -S 参数表示 SOCKS5 代理，-H 参数表示 HTTP 代理 ProxyCommand connect -S 127.0.0.1:7891 %h %p 注意：请务必将上述命令中的 127.0.0.1:7891 替换为你自己在第二步中确认的真实代理地址和端口。如果你的代理是 HTTP 类型，记得将 nc 的 -x 参数或 connect 的 -S 参数相应地修改。\n配置参数解释：\nHostname ssh.github.com: 使用 GitHub 官方提供的备用 SSH 域名，可以有效规避某些针对 github.com 的 DNS 污染。 Port 443: 将 SSH 连接的默认 22 端口切换到 443 (HTTPS) 端口，这可以绕过部分防火墙对 22 端口的封锁。 ProxyCommand: 这是核心指令，它告诉 SSH 在连接 github.com 时，不要直接发起 TCP 连接，而是执行一个指定的命令来建立通道。%h 和 %p 是占位符，分别代表目标主机名（Hostname）和端口（Port）。 步骤 3: 测试连接 保存配置文件后，执行以下命令测试 SSH 连通性：\nssh -T git@github.com 如果看到以下欢迎信息，就说明配置成功了！\nHi your-username! You\u0026#39;ve successfully authenticated, but GitHub does not provide shell access. 4. 方案二：通过 HTTPS 配置全局代理 如果你的仓库地址是 https://github.com/user/repo.git 格式，则需要配置 Git 的 http.proxy 和 https.proxy。这种方式会影响所有使用 Git 的 HTTPS 请求，而不仅限于 GitHub。\n提示：如果你的仓库当前是 SSH 格式，可以先用 git remote set-url origin https://github.com/user/repo.git 切换到 HTTPS 格式。\n步骤 1: 设置 Git 全局代理 执行以下命令，将 Git 的所有 HTTPS 流量都指向你的本地代理。\n# 分别为 HTTP 和 HTTPS 协议设置代理 # 注意这里的代理地址格式是 http://\u0026lt;host\u0026gt;:\u0026lt;port\u0026gt; 或 socks5://\u0026lt;host\u0026gt;:\u0026lt;port\u0026gt; git config --global http.proxy http://127.0.0.1:7890 git config --global https.proxy http://127.0.0.1:7890 步骤 2: 取消代理（需要时） 如果后续不需要代理了，可以通过 --unset 参数来移除配置。\ngit config --global --unset http.proxy git config --global --unset https.proxy 5. 方案三：仅为 GitHub 配置 HTTPS 代理 这是方案二的优化版。如果你不希望代理影响到其他 Git 仓库（例如 Gitee 或 GitLab），只想针对 GitHub 进行配置，可以使用下面的命令。\n设置针对性代理 git config --global http.https://github.com.proxy http://127.0.0.1:7890 取消针对性代理 git config --global --unset http.https://github.com.proxy 这个配置为一个特定的 URL 域设置了专有的代理。\n6. 避坑指南与常见问题 在折腾的过程中，我还是踩了一些坑，这里一并记录下来，方便日后快速排查。\nWindows 下提示 command not found: connect\n原因分析: 多数情况下，Git for Windows 自带 connect.exe。如果出现此提示，可能是 PATH 环境变量未正确配置，或者 Git 安装不完整。 解决方案: 可以在 SSH 配置中直接使用 connect.exe 的绝对路径来规避 PATH 问题。 # 将 ProxyCommand 指向 connect.exe 的绝对路径 ProxyCommand /mingw64/bin/connect -H 127.0.0.1:10808 %h %p 首次连接提示主机真实性无法确认\n现象: 在执行 ssh -T git@github.com 时，终端可能会显示以下信息： The authenticity of host \u0026#39;[ssh.github.com]:443 ([140.82.113.37]:443)\u0026#39; can\u0026#39;t be established. Are you sure you want to continue connecting (yes/no/[fingerprint])? 解决方案: 这并非错误，而是 SSH 的标准安全机制。它表示这是你第一次连接该主机，需要你确认其公钥指纹。 提示：直接输入 yes 并回车即可。SSH 会将该主机的公钥信息保存到 ~/.ssh/known_hosts 文件中，下次连接时便不会再提示。\n连接测试时出现 Connection refused\n原因分析: 这是最常见的错误，表明你的 Git/SSH 请求根本没有成功到达代理服务器。 排查清单: 检查代理软件是否已启动并处于正常工作状态。 再次核对 ~/.ssh/config 或 git config 中填写的端口号是否与代理软件实际监听的端口完全一致。一个数字的错误就会导致失败。 SSH 连接时出现 Broken pipe 错误\n原因分析: 这个错误通常是代理协议类型不匹配导致的。例如，你的代理是 HTTP 类型，但在 ProxyCommand 中却错误地使用了 -S (SOCKS5) 参数。 解决方案: 确保 connect 命令的参数与你的代理协议一致。 如果代理是 HTTP 类型，应使用 -H 参数。 如果代理是 SOCKS5 类型，应使用 -S 参数。 # 示例：将错误的 SOCKS5 参数(-S)修正为正确的 HTTP 参数(-H) ProxyCommand connect -H 127.0.0.1:10808 %h %p ","permalink":"https://GlowStonee233.github.io/posts/2026/git-%E9%85%8D%E7%BD%AE%E4%BB%A3%E7%90%86%E5%A4%87%E5%BF%98%E5%BD%95%E8%A7%A3%E5%86%B3-github-%E8%BF%9E%E6%8E%A5%E8%B6%85%E6%97%B6%E4%B8%8E%E8%AE%BF%E9%97%AE%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98/","summary":"记录了如何通过配置 SSH 和 HTTPS 代理，一劳永逸地解决因网络问题导致的 Git 推送或拉取 GitHub 仓库失败的问题。","title":"Git 配置代理备忘录：解决 GitHub 连接超时与访问失败问题"},{"content":"VS Code 作为我日常编码和学习的主力工具，几乎每天都要和它打交道。一个顺手、高效且赏心悦目的开发环境，对生产力的提升不言而喻。最近花了一些时间，对我的 VS Code 配置进行了一番折腾和优化，主要集中在编码效率和视觉美化两个方面。\n为了防止以后重装系统或者更换设备后忘记这些配置细节，特此记录下来，作为一份个人备忘。\n1. 编码效率优化配置 这部分主要是对 Code Runner 插件和编辑器本身的一些行为进行调整，让编码和调试流程更加顺畅。这些配置都可以通过 VS Code 的设置界面 (快捷键 Ctrl + ,) 搜索到，然后勾选或修改。\nCode Runner: Ignore Selection: true 说明：禁用“运行部分选中代码”的功能。我个人好几次因为不小心选中了某几行代码就执行，导致运行出错。关闭后，Code Runner 将始终运行整个文件，符合我的使用习惯。 Code Runner: Run In Terminal: true 说明：将代码放到 VS Code 内置的终端（Terminal）中运行，而不是在“输出”（Output）面板。这样做的好处是，对于需要交互式输入（如 input()）的程序，可以在终端里直接操作。 Code Runner: Save File Before Run: true 说明：一个必备的保险设置，确保每次运行时执行的都是最新保存的代码，避免因忘记保存而导致调试乌龙。 Editor: Format On Type: true 说明：在我输入代码的过程中自动进行格式化，比如调整缩进、对齐等。对于追求代码整洁的我来说，这个功能极大地提升了幸福感。 Editor: Accept Suggestion On Commit Character: false 说明：这是一个非常关键的设置。关闭它，可以避免在输入分号、括号等触发字符时，编辑器非预期地接受了代码建议，尤其是在我只想换行的时候，它不会强行帮我补全。 2. 编辑器背景美化：注入灵魂 看久了单调的深色或浅色背景，总想来点不一样的。Background 这款插件就能满足我的需求，它允许为 VS Code 的编辑器区域设置自定义背景图片。\n首先，确保你已经在扩展商店中安装了 Background 插件。\n配置的核心步骤是在 settings.json 文件中完成的。可以通过 File \u0026gt; Preferences \u0026gt; Settings，然后在右上角点击“打开设置 (JSON)”图标来访问它。\n找到 \u0026quot;background.editor\u0026quot; 相关的配置项，如果不存在，可以手动添加。关键在于修改 images 数组。\n{ // ... 其他配置项 \u0026#34;background.editor\u0026#34;: { \u0026#34;useFront\u0026#34;: true, \u0026#34;style\u0026#34;: { \u0026#34;background-position\u0026#34;: \u0026#34;100% 100%\u0026#34;, \u0026#34;background-size\u0026#34;: \u0026#34;auto\u0026#34;, \u0026#34;opacity\u0026#34;: 0.6 }, \u0026#34;images\u0026#34;: [ \u0026#34;https://user-images.githubusercontent.com/9987486/40583669-d6189844-61c5-11e8-89e3-c52ad153da09.png\u0026#34;, \u0026#34;https://user-images.githubusercontent.com/9987486/40583670-d6478c9e-61c5-11e8-9551-6b55eacc7b8d.png\u0026#34;, \u0026#34;https://user-images.githubusercontent.com/9987486/40583671-d676c6e4-61c5-11e8-94cb-34ec4a12fa01.png\u0026#34; ], \u0026#34;interval\u0026#34;: 0, \u0026#34;random\u0026#34;: false }, // ... 其他配置项 } 在 images: [] 数组中填入图片的 URL 即可，多个 URL 之间用逗号 , 隔开。\n2.1 如何获取图片 URL 网络图片：直接复制图片的链接地址。 本地图片：可以将本地图片上传到图床，然后使用生成的外链。 提示：如果坚持使用本地图片文件，有一个非常实用的小技巧：直接将本地图片文件拖拽到浏览器（如 Chrome、Edge）的地址栏中打开，浏览器地址栏显示的 file:///... 路径就是可以直接使用的 URL。\n3. 个人 settings.json 完整参考 下面是我当前使用的 settings.json 完整文件，包含了一些未在上面详述的配置，例如针对不同语言的 executorMap 等。仅供参考，可以直接取用你需要的部分。\n注意：这份配置是我个人环境的快照，包含了大量针对特定语言和插件的设置。直接完整复制可能会覆盖你的个人设置或引入不需要的配置。建议按需摘取。\n{ \u0026#34;editor.experimental.treeSitterTelemetry\u0026#34;: true, \u0026#34;editor.minimap.enabled\u0026#34;: false, \u0026#34;editor.unicodeHighlight.nonBasicASCII\u0026#34;: false, \u0026#34;editor.formatOnType\u0026#34;: true, \u0026#34;editor.acceptSuggestionOnCommitCharacter\u0026#34;: false, \u0026#34;code-runner.runInTerminal\u0026#34;: true, \u0026#34;code-runner.saveFileBeforeRun\u0026#34;: true, \u0026#34;code-runner.ignoreSelection\u0026#34;: true, \u0026#34;background.enabled\u0026#34;: true, \u0026#34;background.editor\u0026#34;: { \u0026#34;useFront\u0026#34;: true, \u0026#34;style\u0026#34;: { \u0026#34;background-position\u0026#34;: \u0026#34;100% 100%\u0026#34;, \u0026#34;background-size\u0026#34;: \u0026#34;auto\u0026#34;, \u0026#34;opacity\u0026#34;: 0.6 }, \u0026#34;images\u0026#34;:[ \u0026#34;https://user-images.githubusercontent.com/9987486/40583669-d6189844-61c5-11e8-89e3-c52ad153da09.png\u0026#34;, \u0026#34;https://user-images.githubusercontent.com/9987486/40583670-d6478c9e-61c5-11e8-9551-6b55eacc7b8d.png\u0026#34;, \u0026#34;https://user-images.githubusercontent.com/9987486/40583671-d676c6e4-61c5-11e8-94cb-34ec4a12fa01.png\u0026#34; ], \u0026#34;interval\u0026#34;: 0, \u0026#34;random\u0026#34;: false }, \u0026#34;workbench.iconTheme\u0026#34;: \u0026#34;vscode-icons\u0026#34;, \u0026#34;workbench.colorTheme\u0026#34;: \u0026#34;GitHub Dark Colorblind (Beta)\u0026#34;, \u0026#34;git.autofetch\u0026#34;: true, \u0026#34;diffEditor.hideUnchangedRegions.enabled\u0026#34;: true, \u0026#34;code-runner.executorMap\u0026#34;: { \u0026#34;python\u0026#34;: \u0026#34;python -u\u0026#34;, \u0026#34;c\u0026#34;: \u0026#34;cd $dir \u0026amp;\u0026amp; gcc $fileName -o $fileNameWithoutExt \u0026amp;\u0026amp; $dir$fileNameWithoutExt\u0026#34;, \u0026#34;cpp\u0026#34;: \u0026#34;cd $dir \u0026amp;\u0026amp; g++ $fileName -o $fileNameWithoutExt \u0026amp;\u0026amp; $dir$fileNameWithoutExt\u0026#34;, \u0026#34;java\u0026#34;: \u0026#34;cd $dir \u0026amp;\u0026amp; javac $fileName \u0026amp;\u0026amp; java $fileNameWithoutExt\u0026#34;, \u0026#34;go\u0026#34;: \u0026#34;go run\u0026#34;, \u0026#34;rust\u0026#34;: \u0026#34;cd $dir \u0026amp;\u0026amp; rustc $fileName \u0026amp;\u0026amp; $dir$fileNameWithoutExt\u0026#34;, // ... 其他语言执行映射 }, \u0026#34;code-runner.languageIdToFileExtensionMap\u0026#34;: { \u0026#34;bat\u0026#34;: \u0026#34;.bat\u0026#34;, \u0026#34;powershell\u0026#34;: \u0026#34;.ps1\u0026#34;, \u0026#34;typescript\u0026#34;: \u0026#34;.ts\u0026#34; } } 4. 避坑指南与总结 在这次折腾过程中，也踩了一些小坑，总结如下：\n插件依赖是前提：background.editor 相关的配置项必须在安装了 Background 插件后才会生效。如果直接复制 JSON 配置，务必先检查相关插件是否已安装。 JSON 语法要严谨：在手动编辑 settings.json 时，务必注意 JSON 格式的正确性，特别是对象和数组成员之间的逗号，多一个或少一个都会导致解析失败，从而使整个用户配置失效。 本地图片路径问题：直接复制 Windows 的文件路径（如 D:\\Images\\bg.png）是无效的。必须将其转换为 URL 格式（file:///D:/Images/bg.png）。使用浏览器打开本地文件来获取 URL 是最稳妥的方法。 配置的优先级：VS Code 的配置存在优先级（用户设置 \u0026lt; 工作区设置）。如果发现某项配置不生效，可以检查一下当前工作区（.vscode/settings.json）是否覆盖了用户级别的全局设置。 好了，这次的折腾记录就到这里。希望这份备忘录在未来能帮到我自己。\n","permalink":"https://GlowStonee233.github.io/posts/2026/vs-code-%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE%E5%A4%87%E5%BF%98%E5%BD%95%E6%8F%90%E5%8D%87%E7%BC%96%E7%A0%81%E6%95%88%E7%8E%87%E4%B8%8E%E8%A7%86%E8%A7%89%E4%BD%93%E9%AA%8C/","summary":"记录了几个提升 VS Code 编码效率的关键配置，并详细介绍了如何通过 Background 插件为编辑器设置自定义背景图，作为个人环境的美化备忘。","title":"VS Code 个性化配置备忘录：提升编码效率与视觉体验"},{"content":"平时无论是写博客还是记笔记，Markdown 都是我的主力标记语言。它的语法简洁高效，能让人专注于内容本身。但时间一长，总有一些不常用的语法会忘记，比如表格的对齐、脚注的格式等等。\n每次都去重新搜索感觉效率太低了，干脆自己整理一份核心语法清单，并附上渲染效果，当作速查备忘录。以后忘了就翻一下，特此记录。\n1. 基础文本格式化 这部分是最常用、最基础的语法，用于控制文本的层级和样式。\n1.1 标题 (Headings) 使用 # 号表示标题，一个 # 是一级标题，两个 ## 是二级，最多支持到六级。\n语法示例：\n# 一级标题 ## 二级标题 ### 三级标题 渲染效果：\n一级标题 二级标题 三级标题 1.2 文本强调 (Emphasis) 斜体 (Italic): 使用一对 * 或 _ 包裹文本。 粗体 (Bold): 使用两对 * 或 _ 包裹文本。 粗斜体 (Bold \u0026amp; Italic): 使用三对 * 或 _ 包裹文本。 删除线 (Strikethrough): 使用两对 ~ 包裹文本。 语法示例：\n*这是斜体* _这也是斜体_ **这是粗体** __这也是粗体__ ***这是粗斜体*** ~~这段文本将被标记为删除~~ 渲染效果：\n这是斜体 这也是斜体\n这是粗体 这也是粗体\n这是粗斜体\n这段文本将被标记为删除\n1.3 列表 (Lists) 无序列表: 使用 -、* 或 + 开头，后跟一个空格。 有序列表: 使用 数字. 开头，后跟一个空格。 任务列表: 在列表项后添加 [ ] (未完成) 或 [x] (已完成)。 语法示例：\n- 无序列表项 A - 无序列表项 B 1. 有序列表项 1 2. 有序列表项 2 - [x] 已完成的任务 - [ ] 待办的任务 渲染效果：\n无序列表项 A 无序列表项 B 有序列表项 1 有序列表项 2 已完成的任务 待办的任务 2. 内容嵌入与引用 用于在文章中插入链接、图片、代码等外部或特殊内容。\n2.1 链接 (Links) 语法格式: ``\n语法示例：\n[点击访问 Google](https://www.google.com) 渲染效果：\n点击访问 Google\n提示 如果想在新标签页中打开链接，需要使用 HTML 的 \u0026lt;a\u0026gt; 标签实现，或者依赖主题的配置。Markdown 原生语法不支持此功能。\n2.2 图片 (Images) 语法格式: ![图片替代文字(alt text)](图片地址)\nalt text 在图片无法加载时显示，也有助于 SEO。\n语法示例：\n![Hugo Logo](https://upload.wikimedia.org/wikipedia/commons/a/af/Logo_of_Hugo_the_static_website_generator.svg) 渲染效果：\n2.3 代码 (Code) 2.3.1 行内代码 (Inline Code) 使用一对反引号 ` 包裹代码片段。\n语法示例：\n在 JavaScript 中，可以使用 `console.log()` 来打印日志。 渲染效果：\n在 JavaScript 中，可以使用 console.log() 来打印日志。\n2.3.2 代码块 (Code Block) 使用三对反引号 包裹多行代码，并可在第一组后添加语言标识符以实现语法高亮。\n语法示例：\n```python def hello_world(): print(\u0026#34;Hello, World!\u0026#34;) hello_world() ``` 提示 为了在文档中展示“如何书写一个代码块”，我在外层使用了四个反引号(````)来包裹包含三个反引号的语法示例，这样可以避免解析错误。\n渲染效果：\ndef hello_world(): print(\u0026#34;Hello, World!\u0026#34;) hello_world() 2.4 引用 (Blockquotes) 在段落前添加 \u0026gt; 符号。可以嵌套使用 \u0026gt;\u0026gt;。\n语法示例：\n\u0026gt; 这是一个引用块。 \u0026gt; \u0026gt; 它可以包含多个段落。 \u0026gt; \u0026gt; 这是一个嵌套的引用。 渲染效果：\n这是一个引用块。\n它可以包含多个段落。\n这是一个嵌套的引用。\n3. 结构化数据 用于展示表格、分隔线等结构化内容。\n3.1 表格 (Tables) 使用 | 分隔单元格，使用 - 分隔表头和表体。通过在分隔线中使用 : 来控制列的对齐方式。\n注意 表格的定义部分必须与其前面的段落之间保留一个空行，否则可能无法正确渲染。\n语法示例：\n| 左对齐 | 居中对齐 | 右对齐 | | :--- | :---: | ---: | | Cell 1 | Cell 2 | Cell 3 | | Cell 4 | Cell 5 | Cell 6 | 渲染效果：\n左对齐 居中对齐 右对齐 Cell 1 Cell 2 Cell 3 Cell 4 Cell 5 Cell 6 3.2 水平分割线 (Horizontal Rules) 使用三个或更多的 *、- 或 _ 来创建一条水平分割线。\n语法示例：\n--- *** ___ 渲染效果： 4. 高级与特殊语法 这部分语法在特定场景下非常有用。\n4.1 脚注 (Footnotes) 语法格式: 在需要添加脚注的文本后添加 [^标识符]，然后在文末通过 [^标识符]: 脚注内容 来定义。\n语法示例：\nHugo 是一个基于 Go 语言开发的静态站点生成器[^1]。 [^1]: 更多信息请访问 Hugo 官网。 渲染效果：\nHugo 是一个基于 Go 语言开发的静态站点生成器1。\n提示：脚注的定义内容通常会被渲染器统一收集并展示在页面的最底部。\n4.2 转义字符 (Escaping) 如果你想在文本中显示 Markdown 的特殊语法符号（如 *, #, _），可以在符号前添加反斜杠 \\ 进行转义。\n语法示例：\n\\*这句话不会变成斜体\\* \\# 这不会被渲染成一级标题 渲染效果：\n*这句话不会变成斜体* # 这不会被渲染成一级标题\n4.3 自动链接 (Automatic Links) 将标准的 URL 或邮箱地址用 \u0026lt; 和 \u0026gt; 包裹，Markdown 会自动将其转换为可点击的链接。\n语法示例：\n\u0026lt;https://gohugo.io\u0026gt; \u0026lt;contact@example.com\u0026gt; 渲染效果：\nhttps://gohugo.io contact@example.com\n5. 常见问题与注意事项 在实践中，有几个点很容易混淆或出错，这里单独拎出来备忘一下。\n行内代码 vs 代码块：\n(单反引号) 用于包裹单个词或短语，比如函数名 printf() 或文件名 config.toml。 (三反引号) 用于包裹多行代码片段，可以指定语言实现语法高亮。 列表的缩进与嵌套：\n在父列表项下，通过缩进（通常是 2 个或 4 个空格）来创建子列表。不正确的缩进会导致列表渲染中断或格式错乱。 表格前的空行：\n这个坑我踩过好几次。一定要记住，表格的 | a | b | 定义之前必须有一个完整的空行，否则解析器可能无法识别它是一个表格。 好了，以上就是我整理的核心语法备忘。以后应该能省下不少查资料的时间了。\n推荐阅读Basic writing and formatting syntax\n更多信息请访问 Hugo 官网。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","permalink":"https://GlowStonee233.github.io/posts/2026/%E6%88%91%E7%9A%84-markdown-%E8%AF%AD%E6%B3%95%E6%A0%B8%E5%BF%83%E5%A4%87%E5%BF%98%E5%BD%95%E5%90%AB%E6%B8%B2%E6%9F%93%E6%95%88%E6%9E%9C/","summary":"整理一份 Markdown 常用语法清单，并附上直观的渲染效果，作为个人速查备忘录，方便日常写作时快速查阅。","title":"我的 Markdown 语法核心备忘录（含渲染效果）"},{"content":"最近在折腾 Hugo 配合 PaperMod 主题搭建个人博客时，不管是调整样式还是更新文章，发布流程都让我感到相当头大。由于我不把 Hugo 的构建产物（public 目录）纳入源码版本控制，所以每次发布都需要手动重建 Git 历史。\n经过一番折腾，我决定写一个 Shell 脚本来接管这个流程。这篇备忘录主要记录脚本的实现逻辑和一些需要注意的坑，防止以后自己忘了。\n1. 背景与痛点 在没有自动化脚本之前，我每次更新博客都要经历一套繁琐的流程，不仅效率低下，而且极易出错（例如输错仓库地址）：\n运行 hugo 命令生成静态文件。 cd public 进入构建目录。 git init 初始化临时仓库。 git remote add 关联 GitHub Pages 远程仓库。 git add . 和 git commit 提交更改。 git push -f 强制推送到远程分支。 为了解决这个重复性劳动的痛点，利用 Shell 脚本实现 CI/CD的本地化版本 是最经济的解决方案。\n2. 核心步骤与脚本实现 我在博客项目的根目录下创建了一个名为 deploy.sh 的脚本。该脚本将构建、清理、推送的命令封装在一起，实现了“一键发布”。\n2.1 脚本代码 以下是最终调试通过的脚本内容：\n#!/bin/bash # 自动化部署 Hugo 博客到 GitHub Pages # 脚本功能：构建静态站点 -\u0026gt; 重置 public 目录 Git 历史 -\u0026gt; 强制推送到远程 pages 分支 # --- 配置部分 --- # GitHub Pages 仓库的远程地址 # [Option A] SSH (推荐): git@github.com:yourname/yourname.github.io.git # [Option B] HTTPS: https://github.com/yourname/yourname.github.io.git REPO_URL=\u0026#34;git@github.com:yourname/yourname.github.io.git\u0026#34; # --- 主逻辑 --- # [安全机制] 遇到任何命令执行失败，立即终止脚本 set -e echo \u0026#34;[Step 1/4] Cleaning up old build files...\u0026#34; # 清理旧的构建产物，确保环境纯净 rm -rf public echo \u0026#34;[Step 2/4] Building the static site...\u0026#34; hugo echo \u0026#34;[Step 3/4] Initializing Git and committing changes...\u0026#34; cd public # 动态生成提交信息，包含时间戳 COMMIT_MSG=\u0026#34;Deploy: Update site at $(date \u0026#39;+%Y-%m-%d %H:%M:%S\u0026#39;)\u0026#34; git init git branch -M main git add . git commit -m \u0026#34;$COMMIT_MSG\u0026#34; echo \u0026#34;[Step 4/4] Pushing to the GitHub Pages repository...\u0026#34; git remote add origin \u0026#34;$REPO_URL\u0026#34; # 因本地是新 init 的仓库，历史记录与远程不一致，必须使用 -f 覆盖 git push -f origin main # 返回项目根目录 cd .. echo \u0026#34;Deployment successful!\u0026#34; 2.2 使用方法 在终端（Terminal 或 Git Bash）中赋予脚本执行权限并运行：\nchmod +x deploy.sh ./deploy.sh 3. 免密输入配置方案与安全分析 为了实现真正的“无人值守”自动化，必须解决 git push 时的交互式认证。这里主要有两种方案，经过深入研究，我发现方案 B 存在不容忽视的安全隐患。\n3.1 方案 A：SSH 协议（强烈推荐） 这是最标准且安全的做法。\n配置方式：在本地使用 ssh-keygen 生成密钥对，并将公钥（Public Key）添加到 GitHub 的 Settings -\u0026gt; SSH and GPG keys 中。 脚本设置：将 REPO_URL 变量设置为 git@github.com:... 格式。 优点：基于非对称加密，无需在代码或配置中存储明文密码，且由系统 SSH Agent 管理会话。 3.2 方案 B：HTTPS + Personal Access Token（存在隐患与修复） 如果你由于网络环境限制必须使用 HTTPS，通常的做法是配置 Git 凭证助手。\n常规做法（有坑）： 许多教程建议使用 git config --global credential.helper store。\n安全隐患：此命令会将你的 Personal Access Token (PAT) 以 纯文本 (Plain Text) 形式保存在本地的 ~/.git-credentials 文件中。一旦电脑感染恶意软件或配置文件被误上传，Token 将直接泄露。 安全优化方案： 为了修补上述漏洞，如果必须使用 HTTPS，请严格遵循以下步骤：\n使用安全的凭证管理器： 不要使用 store，而应根据操作系统选择加密存储方式。\nWindows: 推荐安装并使用 GCM (Git Credential Manager)，它会将 Token 加密存储在 Windows 凭据管理器中。 Mac: 使用 osxkeychain，将 Token 存入系统钥匙串。 Linux: 桌面环境 (GNOME/KDE)：推荐配置 libsecret 模式，将凭证存入系统 Keyring 中（需安装 libsecret 库并编译 git helper）。 服务器/临时环境：推荐使用 cache 模式 (git config --global credential.helper 'cache --timeout=3600')，仅在内存中缓存 Token 一小时。 遵循最小权限原则 (Least Privilege)： 在 GitHub 生成 Token 时，仅勾选 public_repo 权限。\n紧急补救（如果你已经使用了 store）： 如果你之前不小心执行过 store 模式，请立即按以下顺序操作以消除隐患：\n清理配置：运行 git config --global --unset credential.helper。 删除文件：手动删除用户根目录下的 ~/.git-credentials 文件（里面存着明文密码！）。 重置凭证：务必去 GitHub 后台 撤销 旧的 Token 并生成新的，因为旧 Token 理论上已视为泄露。 4. 技术原理与安全性分析 在引入脚本前，我主要担心它会不会误删文件。经过对 Bash 行为的分析，这个脚本在设计上包含了几处关键的安全保障：\n进程熔断机制 (set -e)： 脚本启用了 set -e 选项。这指示 Bash 解释器：一旦任何指令返回非零状态码（Exit Code != 0），立即终止执行。这意味着如果 hugo 构建失败（例如 Markdown 语法错误），脚本会立刻退出，绝不会执行后续的 git push，防止了将空站点或错误内容推送到线上。 构建环境隔离 (Isolation)： 所有的 Git 版本控制操作（Init, Add, Commit）都被严格限制在 public 目录下。脚本通过 rm -rf public 保证每次构建都是“纯净”的，避免了 Git 仓库体积随着构建产物的二进制变动而无限膨胀。 强制推送的合理性： 通常我们慎用 git push -f，但在静态站点部署场景下，public 目录被视为构建产物 (Artifacts) 而非源码。我们不需要保留构建产物的历史，只关心最终呈现结果，因此覆盖远程历史是符合预期的。 5. 避坑指南 在使用这套流程的过程中，我踩了一些坑，特此总结如下，避免重蹈覆辙：\n注意：执行脚本前请务必仔细核对以下配置点。\n仓库地址配置错误（高危）\n问题：如果在 REPO_URL 中错误填写了存放 Hugo 源码 的仓库地址。 后果：脚本执行 git push -f 后，你的源码仓库历史将被 public 目录的内容完全覆盖，且极难恢复！ 对策：务必反复确认 REPO_URL 指向的是 username.github.io (Pages 仓库)。 源码仓库的 .gitignore 配置\n问题：如果不配置 .gitignore，public/ 目录可能会被误提交到源码仓库中。 对策：必须在源码根目录的 .gitignore 文件中添加一行 public/，保持源码分支的整洁。 警惕 credential.helper store 陷阱\n问题：在解决 HTTPS 免密推送时，千万不要图省事直接运行 git config --global credential.helper store。 后果：这是一种极其不安全的做法。它会在你的用户根目录下生成一个 .git-credentials 文件，里面明文存储了你的 GitHub 账号和 Token。一旦恶意软件扫描该文件，你的仓库权限将彻底暴露。 对策：坚持使用 SSH 协议。如果必须用 HTTPS，请确保使用基于系统加密的凭证管理器（Windows 的 GCM、macOS 的 Keychain 或 Linux 的 Libsecret/Cache），绝不要裸奔存储凭证。 ","permalink":"https://GlowStonee233.github.io/posts/2026/%E6%8A%80%E6%9C%AF%E5%A4%87%E5%BF%98%E5%88%A9%E7%94%A8-shell-%E8%84%9A%E6%9C%AC%E5%AE%9E%E7%8E%B0-hugo-%E5%8D%9A%E5%AE%A2%E4%B8%80%E9%94%AE%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/","summary":"记录如何通过编写 Shell 脚本，将繁琐的 Hugo 手动构建与 Git 推送流程合并为“一键发布”，并重点排查了 HTTPS 凭证明文存储的安全隐患。","title":"技术备忘：利用 Shell 脚本实现 Hugo 博客一键自动化部署"},{"content":"刚接触 Git 和 GitHub 的新手，通常会遇到两大难题：一是国内网络环境下的连接超时，二是反复输入密码的繁琐。本篇笔记旨在提供一套清晰、高效的解决方案，并整理了常用命令速查表，作为个人备忘。\n1. 基础概念 Git：一个安装在本地的版本控制软件，如同代码的“时光机”，负责追踪文件变更。 GitHub：一个代码托管网站服务，如同存放“时光机”的云端保险库，用于同步、分享和协作。 2. 初始配置 开始前，请确保已完成以下基础设置。\n安装与注册\nGit 工具：访问 git-scm.com 下载并安装。 GitHub 账号：访问 github.com 注册一个账号。 配置个人信息 这是你的代码“署名”，至关重要。打开 Git Bash（或终端）执行：\n# 建议使用 GitHub 提供的匿名邮箱，可在 https://github.com/settings/emails 找到 git config --global user.name \u0026#34;你的GitHub用户名\u0026#34; git config --global user.email \u0026#34;你的GitHub匿名邮箱\u0026#34; 注意 user.name 最好和你的 GitHub 用户名保持一致，但不是强制的。user.email 则必须配置正确，否则可能无法将提交与你的 GitHub 账户关联起来。\n3. 网络加速：配置代理 为解决 git clone 或 git push 时的连接超时问题，最直接的方法是为 Git 配置代理。\n获取代理端口 在你的代理客户端（如 Clash, V2RayN）设置中找到 HTTP 或 SOCKS5 代理端口。常见端口有 7890/10808 (HTTP) 或 7891 (SOCKS5)。\n执行配置命令\n# 方案一：HTTP 代理 (将 7890 换成你的端口) git config --global http.proxy http://127.0.0.1:7890 git config --global https.proxy http://127.0.0.1:7890 # 方案二：SOCKS5 代理 (将 7891 换成你的端口) git config --global http.proxy socks5://127.0.0.1:7891 git config --global https.proxy socks5://127.0.0.1:7891 取消代理 如果不再需要，可使用 --unset 命令移除配置。\ngit config --global --unset http.proxy git config --global --unset https.proxy 4. 核心流程：第一个项目 (HTTPS) 我们以最通用的 HTTPS 方式走一遍完整流程。\n在 GitHub 创建仓库 点击右上角 + -\u0026gt; New repository。建议勾选 Add a README file, Add .gitignore, 和 Choose a license。\n克隆到本地 在仓库页面，点击 \u0026lt;\u0026gt; Code 按钮，复制 HTTPS 标签下的地址。\n# 使用 HTTPS 地址克隆仓库 git clone https://github.com/your-username/my-first-repo.git # 进入项目目录 cd my-first-repo 克隆完成后，用你的代码编辑器（如 VS Code）打开这个项目文件夹，然后开始修改文件。\n修改与推送 本地修改文件后，在终端中执行“三板斧”操作：\n# 1. 添加所有变更到暂存区 git add . # 2. 提交变更，并附上说明 git commit -m \u0026#34;feat: Add my first file\u0026#34; # 3. 推送到 GitHub git push 补充：使用 VS Code 图形化操作 如果你使用 VS Code，上述“三板斧”操作也可以通过其图形界面完成。在左侧“源代码管理”面板中，点击文件旁的 + 号进行暂存 (add)，在输入框填写信息后按 ✔️ 完成提交 (commit)，最后点击“同步更改”按钮进行推送 (push)。\n注意：HTTPS 推送认证 首次 push 时，Git 会要求认证。此时在密码提示框中输入的不是你的 GitHub 登录密码，而是需要预先生成的 Personal Access Token (PAT)。你可以在 GitHub Token 设置页面 生成一个，至少勾选 repo 权限，然后复制 Token 用于认证（Token 只会展示一次，请及时复制）。\n5. 可选进阶：配置 SSH 实现免密 如果不想每次 push 都处理 PAT 认证，配置 SSH 密钥是最佳选择。\n生成并添加密钥\n生成密钥：在终端执行 ssh-keygen -t rsa -b 4096 -C \u0026quot;你的GitHub匿名邮箱\u0026quot;，然后一路回车。 添加公钥：执行 cat ~/.ssh/id_rsa.pub，复制全部输出内容。访问 GitHub SSH Keys 设置页面，点击 New SSH key，将复制的内容粘贴进去并保存。 测试与使用\n测试连接：执行 ssh -T git@github.com，看到欢迎信息即表示成功。 使用方式：此后 clone 仓库时，请务必复制 SSH 格式的地址 (git@github.com:...)，这样克隆的项目才能实现免密推送。 注意：SSH 与代理 git config 配置的 http.proxy 仅对 HTTPS 协议有效，不影响 SSH 协议。如果网络环境严苛到 SSH 协议也无法直连，则需为其单独配置代理（如修改 ~/.ssh/config 文件），这对新手较为复杂。因此，“HTTPS + 代理” 是最稳定通用的入门方案。\n6. Git 常用命令速查表 初始配置与创建 命令 说明 git config --global user.name \u0026quot;你的姓名\u0026quot; 设置全局用户名 (一次性) git config --global user.email \u0026quot;你的邮箱\u0026quot; 设置全局邮箱 (一次性) git init 在当前目录初始化新仓库 git clone \u0026lt;仓库URL\u0026gt; 克隆远程仓库到本地 日常工作 命令 说明 git status 查看工作区和暂存区的状态 git add \u0026lt;文件名/目录\u0026gt; 添加文件到暂存区 (使用 . 添加所有) git commit -m \u0026quot;提交信息\u0026quot; 提交暂存区的更改到本地仓库 git diff 查看工作区与暂存区的差异 git diff --staged 查看暂存区与上次提交的差异 分支操作 命令 说明 git branch 查看所有本地分支 git switch \u0026lt;分支名\u0026gt; 切换到指定分支 git switch -c \u0026lt;新分支名\u0026gt; 创建并切换到新分支 git branch -m \u0026lt;新分支名\u0026gt; 重命名当前分支 git merge \u0026lt;分支名\u0026gt; 将指定分支合并到当前分支 git branch -d \u0026lt;分支名\u0026gt; 删除已合并的分支 远程协作 命令 说明 git remote -v 查看已配置的远程仓库 git remote add \u0026lt;远程名\u0026gt; \u0026lt;仓库URL\u0026gt; 添加一个新的远程仓库 git pull 从远程仓库拉取并合并更新 git fetch 从远程仓库拉取更新，但不合并 git push 推送本地提交到远程仓库 历史与撤销 命令 说明 git log --oneline 单行简洁格式查看提交历史 git restore \u0026lt;文件名\u0026gt; 撤销工作区中对文件的修改 git restore --staged \u0026lt;文件名\u0026gt; 将文件从暂存区移回工作区 git revert \u0026lt;commit-id\u0026gt; 创建一个新提交来撤销指定提交 git reset --hard \u0026lt;commit-id\u0026gt; 强行重置到指定提交，丢弃之后的所有更改 暂存工作 命令 说明 git stash 临时保存未提交的修改 git stash pop 恢复并删除最近一次暂存的修改 7. 总结与避坑指南 网络问题用代理：遇到 Connection timed out，检查第 3 步的代理配置。 HTTPS 推送用 PAT：使用 HTTPS 协议时，认证密码是 Personal Access Token。 免密推送用 SSH：想省去输入 PAT 的麻烦，按第 5 步配置 SSH，并使用 SSH 地址克隆仓库。 代理不影响 SSH：牢记 http.proxy 管不了 SSH 协议的流量。 养成良好习惯：工作开始前 git pull，推送前 git commit -m \u0026quot;清晰的说明\u0026quot;。 ","permalink":"https://GlowStonee233.github.io/posts/2026/git-github-%E9%AB%98%E6%95%88%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97%E4%BB%8E%E4%BB%A3%E7%90%86%E5%8A%A0%E9%80%9F%E5%88%B0-ssh-%E5%85%8D%E5%AF%86/","summary":"一篇高效率的 Git \u0026amp; GitHub 新手入门备忘录。内容涵盖初始配置、代理加速、HTTPS 核心流程、SSH 免密配置，并附带常用命令速查表。","title":"Git \u0026 GitHub 高效入门指南：从代理加速到 SSH 免密"},{"content":"在 CI/CD（如 GitHub Actions）高度普及的今天，选择“手动编译 + 强制推送”的博客部署方式似乎显得有些原始。但对于个人技术博客而言，这种方式让我能最大程度地掌控发布的每一个细节，同时也实现了“源码”与“静态产物”的物理隔离，避免了自动化脚本黑盒带来的调试焦虑。\n本文不仅是简单的安装指南，更是从环境构建到灾难恢复的全流程备忘录。文章重点解决了Hugo Extended 版本的环境依赖（针对 PaperMod 等需要 SCSS 编译的主题），详细拆解了基于 Git 的双仓库管理策略，并补充了在更换设备时如何通过子模块递归克隆实现“一键还原”的方案。\n1. 核心环境与依赖 操作系统：Windows 10/11 + WSL 2 (Ubuntu 24.04 LTS) 生成器：Hugo (Extended Version) 关键点：由于我使用的 PaperMod 主题依赖 SCSS 编译和 PostCSS 功能，必须使用 Hugo Extended 版本，标准版会报错。 版本控制：Git 部署策略：本地编译 public 目录 -\u0026gt; git push -f 覆盖远端 GitHub Pages 仓库。 2. 环境搭建：安装 Hugo Extended Ubuntu 默认 apt 源中的 Hugo 版本通常非常老旧且不包含 Extended 功能，因此强烈建议直接下载官方 .deb 包安装。\n2.1 下载与安装 访问 Hugo GitHub Releases 页面获取最新版本链接（以下以 0.154.5 为例）：\n# 1. 下载 Extended 版本的 .deb 包 (请根据最新版本号修改 URL) wget wget https://github.com/gohugoio/hugo/releases/download/v0.154.5/hugo_extended_0.154.5_linux-amd64.deb # 2. 执行安装 sudo dpkg -i hugo_extended_0.154.5_linux-amd64.deb 2.2 验证安装 安装完成后，必须验证版本是否包含 extended 标识：\nhugo version # 预期输出示例: # hugo v0.125.0-5nd7s8d6+extended linux/amd64 注意：一定要看到 extended 字样才算成功。\n3. 项目初始化与配置 3.1 创建站点 使用 Git Submodule 管理主题，保持项目结构整洁。\n# 创建站点 hugo new site myblog cd myblog # 初始化 Git (源码库) git init # 拉取 PaperMod 主题 git submodule add --depth=1 https://github.com/adityatelange/hugo-PaperMod.git themes/PaperMod 3.2 关键配置 (hugo.toml) 编辑根目录下的 hugo.toml。这是构建时的唯一真理来源。\nbaseURL = \u0026#34;https://yourname.github.io/\u0026#34; # ⚠️ 必须与 GitHub Pages 地址完全一致，且以 / 结尾,yourname 是 GitHub 用户名 languageCode = \u0026#34;zh-cn\u0026#34; title = \u0026#34;Tech Memo\u0026#34; theme = \u0026#34;PaperMod\u0026#34; [params] defaultTheme = \u0026#34;auto\u0026#34; ShowCodeCopyButtons = true 4. 日常写作与发布流水线 这是每次更新文章时需要严格执行的标准操作序列。\n第一步：新建文章 使用 Hugo CLI 生成带标准 Front Matter 的文件，避免手动创建出错。\nhugo new content posts/my-new-post.md 使用编辑器打开并修改元数据：\ndraft: 将 true 改为 false（否则生成时会被跳过）。 date: 格式必须严格遵守 YYYY-MM-DD (如 2024-05-21)。 第二步：本地预览 启动本地服务器，实时查看渲染效果。\nhugo server -D # -D 参数表示包含草稿 (Drafts)，方便预览还未发布的文章 浏览器访问 http://localhost:1313 检查排版。\n第三步：清理与编译 (Build) 确认无误后，停止预览，开始生成最终网页。为了防止历史残留文件导致的问题，建议先清理后构建。\n# 1. 彻底删除旧的构建目录 rm -rf public # 2. 执行静态编译 hugo 执行成功后，根目录下会重新生成一个 public 文件夹，其中包含了网站所有的静态资源（HTML/CSS/JS）。\n第四步：推送部署 (Deploy) ⚠️ 关键步骤：我们将 public 目录视为一个独立的、临时的 Git 仓库，每次都强制推送到 GitHub Pages。\n# 1. 进入静态资源目录 cd public # 2. 初始化为全新仓库 (抛弃旧的历史) git init git branch -M main # 3. 关联远程仓库 (GitHub Pages 仓库) git remote add origin https://github.com/yourname/yourname.github.io.git # 4. 暂存并提交 git add . git commit -m \u0026#34;Deploy: update blog content $(date \u0026#39;+%Y-%m-%d %H:%M\u0026#39;)\u0026#34; # 5. 强制推送到 GitHub # 说明：因为是全新 init 的仓库，与远程历史不符，必须使用 -f (--force) git push -u -f origin main 5. 核心原理：双仓库策略 为了保证数据安全和逻辑清晰，我采用了源码与产物分离的策略：\n源码仓库 (Source)：\n位置：本地 ~/myblog (推荐推送到 GitHub 私有仓库备份)。 内容：Markdown 源码、配置文件、原始图片。 设置：在 .gitignore 中添加 /public，防止编译产物污染源码库。 发布仓库 (Pages)：\n位置：GitHub 上的 yourname.github.io。 内容：仅包含 public 文件夹内的 HTML/CSS/JS。 逻辑：这是源码的“快照”。通过 rm -rf public 和 git push -f，我们保证每次发布的都是最纯净的版本，且不需要在发布仓库保留冗余的 Commit 历史。 6. 避坑指南 Extended 版本报错\n如果在执行 hugo 时出现 MIME type、PostCSS 或 TOCSS 相关的错误，99% 是因为你装成了 Hugo 标准版。请重新参照第 2 节安装 Extended 版。 样式丢失 (CSS 404)\n部署后如果页面只有文字没有排版，检查 hugo.toml 中的 baseURL。 它必须完全匹配你的 GitHub Pages URL（例如 https://username.github.io/），末尾的斜杠 / 最好加上。 文章不显示\n检查文章头部的 draft: true 是否改为了 false。 检查 date 是否是未来时间（Hugo 默认不渲染未来日期的文章）。 操作路径错误\nhugo 构建命令必须在 项目根目录 执行。 git push 部署命令必须在 public 目录 内执行。 7.备份与还原流程 基于“源码”与“产物”分离的双仓库策略，我们的备份重心完全在于源码仓库 (Source Repo)。只要源码在，网站随时可以重生。以下是日常备份和更换电脑时的还原步骤。\n1.源码日常备份 在写完文章并部署（git push -f 到了 GitHub Pages）之后，不要忘记将源码同步到你的私有仓库。\n操作位置：项目根目录 ~/myblog\n# 1. 确认不在 public 目录中 cd ~/myblog # 2. 提交源码变更 git add . git commit -m \u0026#34;Backup: add new post and update config\u0026#34; # 3. 推送到私有源码仓库 (Source Repo) git push origin main 注意：由于 .gitignore 中已经忽略了 /public 目录，这里只会上传 Markdown、配置文件和主题设置，不会上传生成的 HTML 垃圾。\n2.异地还原/迁移 (更换电脑/重装系统) 假设你在一台全新的 WSL 环境中，需要恢复写作环境，请严格按照以下步骤操作。\n第一步：安装环境 重新按照本文第 2 节的方法，安装 Hugo Extended 版本。\n第二步：克隆源码 (一步到位) 使用 --recursive 参数，在克隆源码仓库的同时，自动拉取 PaperMod 主题文件（子模块）。\n# 核心命令：--recursive 会自动处理子模块 git clone --recursive https://github.com/yourname/myblog-source.git myblog cd myblog 第三步：验证与恢复 此时，源码和主题都已就绪。你可以直接尝试运行本地预览：\nhugo server -D 如果一切正常，即可开始新一轮的写作。下次发布时，Hugo 会自动重新创建 public 目录，你无需手动从旧电脑拷贝该文件夹。\n3.常见问题处理 忘记加 \u0026ndash;recursive 怎么办？ 如果你手快直接用了 git clone，你会发现 themes/PaperMod 文件夹是空的，Hugo 会报错。此时在项目根目录补救执行以下命令即可： git submodule update --init --recursive Public 目录冲突：如果在还原后发现 public 目录里有奇怪的文件，直接 rm -rf public 删掉即可，Hugo 会负责重新生成。 ","permalink":"https://GlowStonee233.github.io/posts/2026/wsl-%E7%8E%AF%E5%A2%83%E4%B8%8B-hugo--github-pages-%E6%89%8B%E5%8A%A8%E9%83%A8%E7%BD%B2%E5%85%A8%E8%AE%B0%E5%BD%95/","summary":"记录在 Windows Subsystem for Linux (WSL) 环境中搭建 Hugo (Extended) 博客，并完全通过 Git 命令手动管理发布流程的详细步骤与避坑指南。","title":"WSL 环境下 Hugo + GitHub Pages 手动部署全记录"}]